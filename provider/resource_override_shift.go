// DO NOT MODIFY: This file is generated by tools/generate.js. Any changes will be overwritten during the next build.

package provider

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/rootlyhq/terraform-provider-rootly/v2/client"
	"github.com/rootlyhq/terraform-provider-rootly/v2/tools"
)

func resourceOverrideShift() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceOverrideShiftCreate,
		ReadContext:   resourceOverrideShiftRead,
		// UpdateContext omitted - all fields are ForceNew (UPDATE endpoint returns 404)
		DeleteContext: resourceOverrideShiftDelete,
		Importer: &schema.ResourceImporter{
			StateContext: resourceOverrideShiftImport,
		},
		Schema: map[string]*schema.Schema{

			"schedule_id": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "ID of schedule",
			},

			"rotation_id": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "ID of rotation",
			},

			"starts_at": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "Start datetime of shift",
			},

			"ends_at": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "End datetime of shift",
			},

			"is_override": &schema.Schema{
				Type:        schema.TypeBool,
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "Denotes shift is an override shift. Value must be one of true or false",
			},

			"shift_override": &schema.Schema{
				Type: schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "Override metadata",
			},

			"user": &schema.Schema{
				Type: schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				WriteOnly:   false,
				Description: "User metadata",
			},
		},
	}
}

func resourceOverrideShiftCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Creating OverrideShift"))

	s := &client.OverrideShift{}

	if value, ok := d.GetOkExists("schedule_id"); ok {
		s.ScheduleId = value.(string)
	}
	if value, ok := d.GetOkExists("rotation_id"); ok {
		s.RotationId = value.(string)
	}
	if value, ok := d.GetOkExists("starts_at"); ok {
		s.StartsAt = value.(string)
	}
	if value, ok := d.GetOkExists("ends_at"); ok {
		s.EndsAt = value.(string)
	}
	if value, ok := d.GetOkExists("is_override"); ok {
		s.IsOverride = tools.Bool(value.(bool))
	}
	if value, ok := d.GetOkExists("shift_override"); ok {
		s.ShiftOverride = value.(map[string]interface{})
	}
	if value, ok := d.GetOkExists("user"); ok {
		if userMap, ok := value.(map[string]interface{}); ok {
			if userIdStr, ok := userMap["id"].(string); ok {
				if userId, err := strconv.Atoi(userIdStr); err == nil {
					s.UserId = userId
				}
			}
		}
	}

	res, err := c.CreateOverrideShift(s)
	if err != nil {
		return diag.Errorf("Error creating override_shift: %s", err.Error())
	}

	d.SetId(res.ID)
	tflog.Trace(ctx, fmt.Sprintf("created a override_shift resource: %s", d.Id()))

	// Set the attributes from the CREATE response directly instead of calling Read
	// because override_shifts don't have a working GET endpoint
	d.Set("schedule_id", res.ScheduleId)
	d.Set("rotation_id", res.RotationId)
	// Keep the original config values for starts_at and ends_at to avoid timezone drift
	d.Set("starts_at", d.Get("starts_at"))
	d.Set("ends_at", d.Get("ends_at"))
	d.Set("is_override", res.IsOverride)
	d.Set("shift_override", res.ShiftOverride)
	// Keep the original config value for user to avoid format drift
	d.Set("user", d.Get("user"))

	return nil
}

func resourceOverrideShiftRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	shiftId := d.Id()
	tflog.Trace(ctx, fmt.Sprintf("Reading OverrideShift: %s", shiftId))

	// Override shifts don't have a working GET endpoint in the Rootly API
	// The /v1/override_shifts/{id} endpoint returns 404 even for valid shifts
	// We need to use the LIST endpoint: /v1/schedules/{schedule_id}/override_shifts
	scheduleId, ok := d.GetOk("schedule_id")
	if !ok || scheduleId == "" {
		tflog.Warn(ctx, fmt.Sprintf("Cannot refresh OverrideShift %s without schedule_id", shiftId))
		return nil
	}

	// List all override shifts for this schedule (pagination handled by client)
	shiftsInterface, err := c.ListOverrideShifts(scheduleId.(string), nil)
	if err != nil {
		return diag.Errorf("Error listing override_shifts for schedule %s: %s", scheduleId, err.Error())
	}

	// Find the shift with matching ID
	var shift *client.OverrideShift
	for _, shiftInterface := range shiftsInterface {
		s := shiftInterface.(*client.OverrideShift)
		if s.ID == shiftId {
			shift = s
			break
		}
	}

	if shift == nil {
		tflog.Warn(ctx, fmt.Sprintf("OverrideShift %s not found, removing from state", shiftId))
		d.SetId("")
		return nil
	}

	// Populate state from the shift data
	d.Set("schedule_id", shift.ScheduleId)
	d.Set("rotation_id", shift.RotationId)
	d.Set("starts_at", shift.StartsAt)
	d.Set("ends_at", shift.EndsAt)
	d.Set("is_override", shift.IsOverride)
	d.Set("shift_override", shift.ShiftOverride)

	// Convert User object to map for Terraform state
	if shift.User != nil {
		userMap := map[string]interface{}{
			"id": shift.User.ID,
		}
		d.Set("user", userMap)
	}

	return nil
}

func resourceOverrideShiftDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Trace(ctx, fmt.Sprintf("Deleting OverrideShift: %s", d.Id()))

	// WARNING: The Rootly API does not have a working DELETE endpoint for override shifts
	// The /v1/override_shifts/{id} endpoint returns 404 even for valid shifts
	// This means the shift will remain in Rootly and must be manually deleted via the UI
	tflog.Warn(ctx, fmt.Sprintf("Override shift %s removed from Terraform state but still exists in Rootly (DELETE endpoint not available). Please manually delete from Rootly UI if needed.", d.Id()))

	// Remove from state anyway
	d.SetId("")

	return diag.Diagnostics{
		diag.Diagnostic{
			Severity: diag.Warning,
			Summary:  "Override shift removed from state only",
			Detail:   fmt.Sprintf("Override shift %s has been removed from Terraform state, but the DELETE API endpoint is not available. The shift still exists in Rootly and must be manually deleted via the Rootly UI at https://rootly.com/schedules.", d.Id()),
		},
	}
}

// Custom import function for override shifts
// Format: {schedule_id}:{shift_id}
func resourceOverrideShiftImport(ctx context.Context, d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	importId := d.Id()

	parts := strings.Split(importId, ":")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid import ID format. Use: {schedule_id}:{shift_id}")
	}

	scheduleId := parts[0]
	shiftId := parts[1]

	// Set the schedule_id in state so Read can use it
	d.Set("schedule_id", scheduleId)
	d.SetId(shiftId)

	// Call Read to populate the rest of the state
	diags := resourceOverrideShiftRead(ctx, d, meta)
	if diags.HasError() {
		return nil, fmt.Errorf("failed to read override shift: %v", diags)
	}

	if d.Id() == "" {
		return nil, fmt.Errorf("override shift %s not found in schedule %s", shiftId, scheduleId)
	}

	return []*schema.ResourceData{d}, nil
}

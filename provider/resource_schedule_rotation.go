// DO NOT MODIFY: This file is generated by tools/generate.js. Any changes will be overwritten during the next build.

package provider

import (
	"context"
	"errors"
	"fmt"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/rootlyhq/terraform-provider-rootly/v2/client"
	"github.com/rootlyhq/terraform-provider-rootly/v2/tools"
)

func resourceScheduleRotation() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceScheduleRotationCreate,
		ReadContext:   resourceScheduleRotationRead,
		UpdateContext: resourceScheduleRotationUpdate,
		DeleteContext: resourceScheduleRotationDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: map[string]*schema.Schema{

			"schedule_id": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    false,
				Required:    true,
				Optional:    false,
				ForceNew:    true,
				Description: "The ID of parent schedule",
			},

			"name": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    false,
				Required:    true,
				Optional:    false,
				ForceNew:    false,
				Description: "The name of the schedule rotation",
			},

			"position": &schema.Schema{
				Type:        schema.TypeInt,
				Computed:    true,
				Required:    false,
				Optional:    true,
				ForceNew:    false,
				Description: "Position of the schedule rotation",
			},

			"schedule_rotationable_type": &schema.Schema{
				Type:        schema.TypeString,
				Default:     "ScheduleDailyRotation",
				Required:    false,
				Optional:    true,
				ForceNew:    false,
				Description: "Schedule rotation type. Value must be one of `ScheduleDailyRotation`, `ScheduleWeeklyRotation`, `ScheduleBiweeklyRotation`, `ScheduleMonthlyRotation`, `ScheduleCustomRotation`.",
			},

			"active_all_week": &schema.Schema{
				Type:        schema.TypeBool,
				Computed:    true,
				Required:    false,
				Optional:    true,
				Description: "Schedule rotation active all week?. Value must be one of true or false",
			},

			"active_days": &schema.Schema{
				Type: schema.TypeList,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				DiffSuppressFunc: tools.EqualIgnoringOrder,
				Computed:         true,
				Required:         false,
				Optional:         true,
				Description:      "Value must be one of `S`, `M`, `T`, `W`, `R`, `F`, `U`.",
			},

			"active_time_type": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    true,
				Required:    false,
				Optional:    true,
				ForceNew:    false,
				Description: "Value must be one of `all_day`, `same_time`, or `custom`. The value chosen will override `active_time_attributes` in any `rootly_schedule_rotation_active_day` resources linked to this `rootly_schedule_rotation`.",
			},

			"active_time_attributes": &schema.Schema{
				Type:             schema.TypeList,
				Computed:         true,
				Required:         false,
				Optional:         true,
				Description:      "Schedule rotation's active times",
				DiffSuppressFunc: tools.EqualIgnoringOrder,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"start_time": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Required:    false,
							Optional:    true,
							ForceNew:    false,
							Description: "Start time for schedule rotation active time",
						},

						"end_time": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Required:    false,
							Optional:    true,
							ForceNew:    false,
							Description: "End time for schedule rotation active time",
						},
					},
				},
			},

			"time_zone": &schema.Schema{
				Type:        schema.TypeString,
				Default:     "Etc/UTC",
				Required:    false,
				Optional:    true,
				ForceNew:    false,
				Description: "A valid IANA time zone name.",
			},

			"start_time": &schema.Schema{
				Type:        schema.TypeString,
				Required:    false,
				Optional:    true,
				ForceNew:    false,
				Description: "ISO8601 date and time when rotation starts. Shifts will only be created after this time.",
			},

			"end_time": &schema.Schema{
				Type:        schema.TypeString,
				Required:    false,
				Optional:    true,
				ForceNew:    false,
				Description: "ISO8601 date and time when rotation ends. Shifts will only be created before this time.",
			},

			"schedule_rotationable_attributes": &schema.Schema{
				Type: schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
				Computed:    false,
				Required:    true,
				Optional:    false,
				Description: "handoff_time and/or handoff_day may be required, depending on schedule_rotationable_type. Please see API docs for options based on schedule_rotationable_type: https://docs.rootly.com/api-reference/schedulerotations/creates-a-schedule-rotation#response-data-attributes-schedule-rotationable-attributes",
			},

			"schedule_rotation_members": &schema.Schema{
				Type:             schema.TypeList,
				Computed:         false,
				Required:         false,
				Optional:         true,
				Sensitive:        false,
				ForceNew:         false,
				WriteOnly:        false,
				Description:      "Schedule rotation members. You can only add schedule rotation members if your account has schedule nesting feature enabled.",
				DiffSuppressFunc: tools.EqualIgnoringOrder,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"member_id": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    false,
							Required:    true,
							Optional:    false,
							Sensitive:   false,
							ForceNew:    false,
							WriteOnly:   false,
							Description: "ID of the member",
						},
						"member_type": &schema.Schema{
							Type:         schema.TypeString,
							Computed:     false,
							Required:     true,
							Optional:     false,
							Sensitive:    false,
							ForceNew:     false,
							WriteOnly:    false,
							Description:  "Type of member. Value must be one of `Schedule` or `User`.",
							ValidateFunc: validation.StringInSlice([]string{"Schedule", "User"}, false),
						},
						"position": &schema.Schema{
							Type:        schema.TypeInt,
							Computed:    true,
							Required:    false,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    false,
							WriteOnly:   false,
							Description: "Position of the member in rotation",
						},
					},
				},
			},
		},
	}
}

func resourceScheduleRotationCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)

	tflog.Trace(ctx, fmt.Sprintf("Creating ScheduleRotation"))

	s := &client.ScheduleRotation{}

	if value, ok := d.GetOkExists("schedule_id"); ok {
		s.ScheduleId = value.(string)
	}
	if value, ok := d.GetOkExists("name"); ok {
		s.Name = value.(string)
	}
	if value, ok := d.GetOkExists("position"); ok {
		s.Position = value.(int)
	}
	if value, ok := d.GetOkExists("schedule_rotationable_type"); ok {
		s.ScheduleRotationableType = value.(string)
	}
	if value, ok := d.GetOkExists("active_all_week"); ok {
		s.ActiveAllWeek = tools.Bool(value.(bool))
	}
	if value, ok := d.GetOkExists("active_days"); ok {
		s.ActiveDays = value.([]interface{})
	}
	if value, ok := d.GetOkExists("active_time_type"); ok {
		s.ActiveTimeType = value.(string)
	}
	if value, ok := d.GetOkExists("active_time_attributes"); ok {
		s.ActiveTimeAttributes = value.([]interface{})
	}
	if value, ok := d.GetOkExists("time_zone"); ok {
		s.TimeZone = value.(string)
	}
	if value, ok := d.GetOkExists("start_time"); ok {
		s.StartTime = value.(string)
	}
	if value, ok := d.GetOkExists("end_time"); ok {
		s.EndTime = value.(string)
	}
	if value, ok := d.GetOkExists("schedule_rotationable_attributes"); ok {
		s.ScheduleRotationableAttributes = value.(map[string]interface{})
	}
	if value, ok := d.GetOkExists("schedule_rotation_members"); ok {
		s.ScheduleRotationMembers = value.([]interface{})
	}

	res, err := c.CreateScheduleRotation(s)
	if err != nil {
		return diag.Errorf("Error creating schedule_rotation: %s", err.Error())
	}

	d.SetId(res.ID)
	tflog.Trace(ctx, fmt.Sprintf("created a schedule_rotation resource: %s", d.Id()))

	return resourceScheduleRotationRead(ctx, d, meta)
}

func resourceScheduleRotationRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Reading ScheduleRotation: %s", d.Id()))

	item, err := c.GetScheduleRotation(d.Id())
	if err != nil {
		// In the case of a NotFoundError, it means the resource may have been removed upstream
		// We just remove it from the state.
		if errors.Is(err, client.NewNotFoundError("")) && !d.IsNewResource() {
			tflog.Warn(ctx, fmt.Sprintf("ScheduleRotation (%s) not found, removing from state", d.Id()))
			d.SetId("")
			return nil
		}

		return diag.Errorf("Error reading schedule_rotation: %s", d.Id())
	}

	d.Set("schedule_id", item.ScheduleId)
	d.Set("name", item.Name)
	d.Set("position", item.Position)
	d.Set("schedule_rotationable_type", item.ScheduleRotationableType)
	d.Set("active_all_week", item.ActiveAllWeek)
	d.Set("active_days", item.ActiveDays)
	d.Set("active_time_type", item.ActiveTimeType)
	d.Set("active_time_attributes", item.ActiveTimeAttributes)
	d.Set("time_zone", item.TimeZone)
	d.Set("start_time", item.StartTime)
	d.Set("end_time", item.EndTime)
	d.Set("schedule_rotation_members", item.ScheduleRotationMembers)

	// Convert any numeric values to strings for schedule_rotationable_attributes
	if item.ScheduleRotationableAttributes != nil {
		convertedAttrs := make(map[string]interface{})
		for k, v := range item.ScheduleRotationableAttributes {
			switch val := v.(type) {
			case int, int32, int64:
				convertedAttrs[k] = fmt.Sprintf("%d", val)
			case float32, float64:
				convertedAttrs[k] = fmt.Sprintf("%g", val)
			default:
				convertedAttrs[k] = fmt.Sprintf("%v", val)
			}
		}
		d.Set("schedule_rotationable_attributes", convertedAttrs)
	}

	return nil
}

func resourceScheduleRotationUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Updating ScheduleRotation: %s", d.Id()))

	s := &client.ScheduleRotation{}

	if d.HasChange("schedule_id") {
		s.ScheduleId = d.Get("schedule_id").(string)
	}
	if d.HasChange("name") {
		s.Name = d.Get("name").(string)
	}
	if d.HasChange("position") {
		s.Position = d.Get("position").(int)
	}

	s.ScheduleRotationableType = d.Get("schedule_rotationable_type").(string)

	if d.HasChange("active_all_week") {
		s.ActiveAllWeek = tools.Bool(d.Get("active_all_week").(bool))
	}
	if d.HasChange("active_days") {
		s.ActiveDays = d.Get("active_days").([]interface{})
	}
	if d.HasChange("active_time_type") {
		s.ActiveTimeType = d.Get("active_time_type").(string)
	}
	if d.HasChange("active_time_attributes") {
		s.ActiveTimeAttributes = d.Get("active_time_attributes").([]interface{})
	}
	if d.HasChange("time_zone") {
		s.TimeZone = d.Get("time_zone").(string)
	}
	if d.HasChange("start_time") {
		s.StartTime = d.Get("start_time").(string)
	}
	if d.HasChange("end_time") {
		s.EndTime = d.Get("end_time").(string)
	}
	if d.HasChange("schedule_rotationable_attributes") {
		s.ScheduleRotationableAttributes = d.Get("schedule_rotationable_attributes").(map[string]interface{})
	}
	if d.HasChange("schedule_rotation_members") {
		if value, ok := d.GetOk("schedule_rotation_members"); value != nil && ok {
			s.ScheduleRotationMembers = value.([]interface{})
		} else {
			s.ScheduleRotationMembers = []interface{}{}
		}
	}

	_, err := c.UpdateScheduleRotation(d.Id(), s)
	if err != nil {
		return diag.Errorf("Error updating schedule_rotation: %s", err.Error())
	}

	return resourceScheduleRotationRead(ctx, d, meta)
}

func resourceScheduleRotationDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Deleting ScheduleRotation: %s", d.Id()))

	err := c.DeleteScheduleRotation(d.Id())
	if err != nil {
		// In the case of a NotFoundError, it means the resource may have been removed upstream.
		// We just remove it from the state.
		if errors.Is(err, client.NewNotFoundError("")) && !d.IsNewResource() {
			tflog.Warn(ctx, fmt.Sprintf("ScheduleRotation (%s) not found, removing from state", d.Id()))
			d.SetId("")
			return nil
		}
		return diag.Errorf("Error deleting schedule_rotation: %s", err.Error())
	}

	d.SetId("")

	return nil
}

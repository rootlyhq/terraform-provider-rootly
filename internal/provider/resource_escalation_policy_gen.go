// Code generated by providergen. DO NOT EDIT.
package provider

import (
	"bytes"
	"context"
	"fmt"
	"net/http"

	"github.com/DataDog/jsonapi"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/jianyuan/go-utils/ptr"
	supertypes "github.com/orange-cloudavenue/terraform-plugin-framework-supertypes"
	"github.com/rootlyhq/terraform-provider-rootly/v2/internal/apiclient"
	"github.com/rootlyhq/terraform-provider-rootly/v2/internal/tfutils"
)

var _ resource.Resource = (*EscalationPolicyResource)(nil)
var _ resource.ResourceWithImportState = (*EscalationPolicyResource)(nil)

func NewEscalationPolicyResource() resource.Resource {
	return &EscalationPolicyResource{}
}

type EscalationPolicyResource struct {
	baseResource
}

func (r *EscalationPolicyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_escalation_policy"
}

func (r *EscalationPolicyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The ID of the escalation policy",
				Computed:            true,
				CustomType:          supertypes.StringType{},
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "The name of the escalation policy",
				Required:            true,
				CustomType:          supertypes.StringType{},
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "The description of the escalation policy",
				Optional:            true,
				Computed:            true,
				CustomType:          supertypes.StringType{},
			},
			"repeat_count": schema.Int64Attribute{
				MarkdownDescription: "The number of times this policy will be executed until someone acknowledges the alert",
				Optional:            true,
				Computed:            true,
				CustomType:          supertypes.Int64Type{},
			},
			"created_by_user_id": schema.Int64Attribute{
				MarkdownDescription: "User who created the escalation policy",
				Computed:            true,
				CustomType:          supertypes.Int64Type{},
			},
			"last_updated_by_user_id": schema.Int64Attribute{
				MarkdownDescription: "User who updated the escalation policy",
				Computed:            true,
				CustomType:          supertypes.Int64Type{},
			},
			"group_ids": schema.SetAttribute{
				MarkdownDescription: "Associated groups (alerting the group will trigger escalation policy)",
				Optional:            true,
				Computed:            true,
				CustomType:          supertypes.NewSetTypeOf[string](ctx),
			},
			"service_ids": schema.SetAttribute{
				MarkdownDescription: "Associated services (alerting the service will trigger escalation policy)",
				Optional:            true,
				Computed:            true,
				CustomType:          supertypes.NewSetTypeOf[string](ctx),
			},
			"business_hours": schema.SingleNestedAttribute{
				MarkdownDescription: "",
				Optional:            true,
				Computed:            true,
				CustomType:          supertypes.NewSingleNestedObjectTypeOf[EscalationPolicyResourceModelBusinessHours](ctx),
				Attributes: map[string]schema.Attribute{
					"time_zone": schema.StringAttribute{
						MarkdownDescription: "Time zone for business hours Value must be one of `International Date Line West`, `Etc/GMT+12`, `American Samoa`, `Pacific/Pago_Pago`, `Midway Island`, `Pacific/Midway`, `Hawaii`, `Pacific/Honolulu`, `Alaska`, `America/Juneau`, `Pacific Time (US & Canada)`, `America/Los_Angeles`, `Tijuana`, `America/Tijuana`, `Arizona`, `America/Phoenix`, `Mazatlan`, `America/Mazatlan`, `Mountain Time (US & Canada)`, `America/Denver`, `Central America`, `America/Guatemala`, `Central Time (US & Canada)`, `America/Chicago`, `Chihuahua`, `America/Chihuahua`, `Guadalajara`, `America/Mexico_City`, `Mexico City`, `America/Mexico_City`, `Monterrey`, `America/Monterrey`, `Saskatchewan`, `America/Regina`, `Bogota`, `America/Bogota`, `Eastern Time (US & Canada)`, `America/New_York`, `Indiana (East)`, `America/Indiana/Indianapolis`, `Lima`, `America/Lima`, `Quito`, `America/Lima`, `Atlantic Time (Canada)`, `America/Halifax`, `Caracas`, `America/Caracas`, `Georgetown`, `America/Guyana`, `La Paz`, `America/La_Paz`, `Puerto Rico`, `America/Puerto_Rico`, `Santiago`, `America/Santiago`, `Newfoundland`, `America/St_Johns`, `Asuncion`, `America/Asuncion`, `Brasilia`, `America/Sao_Paulo`, `Buenos Aires`, `America/Argentina/Buenos_Aires`, `Montevideo`, `America/Montevideo`, `Greenland`, `America/Nuuk`, `Mid-Atlantic`, `Atlantic/South_Georgia`, `Azores`, `Atlantic/Azores`, `Cape Verde Is.`, `Atlantic/Cape_Verde`, `Casablanca`, `Africa/Casablanca`, `Dublin`, `Europe/Dublin`, `Edinburgh`, `Europe/London`, `Lisbon`, `Europe/Lisbon`, `London`, `Europe/London`, `Monrovia`, `Africa/Monrovia`, `UTC`, `Etc/UTC`, `Amsterdam`, `Europe/Amsterdam`, `Belgrade`, `Europe/Belgrade`, `Berlin`, `Europe/Berlin`, `Bern`, `Europe/Zurich`, `Bratislava`, `Europe/Bratislava`, `Brussels`, `Europe/Brussels`, `Budapest`, `Europe/Budapest`, `Copenhagen`, `Europe/Copenhagen`, `Ljubljana`, `Europe/Ljubljana`, `Madrid`, `Europe/Madrid`, `Paris`, `Europe/Paris`, `Prague`, `Europe/Prague`, `Rome`, `Europe/Rome`, `Sarajevo`, `Europe/Sarajevo`, `Skopje`, `Europe/Skopje`, `Stockholm`, `Europe/Stockholm`, `Vienna`, `Europe/Vienna`, `Warsaw`, `Europe/Warsaw`, `West Central Africa`, `Africa/Algiers`, `Zagreb`, `Europe/Zagreb`, `Zurich`, `Europe/Zurich`, `Athens`, `Europe/Athens`, `Bucharest`, `Europe/Bucharest`, `Cairo`, `Africa/Cairo`, `Harare`, `Africa/Harare`, `Helsinki`, `Europe/Helsinki`, `Jerusalem`, `Asia/Jerusalem`, `Kaliningrad`, `Europe/Kaliningrad`, `Kyiv`, `Europe/Kiev`, `Pretoria`, `Africa/Johannesburg`, `Riga`, `Europe/Riga`, `Sofia`, `Europe/Sofia`, `Tallinn`, `Europe/Tallinn`, `Vilnius`, `Europe/Vilnius`, `Baghdad`, `Asia/Baghdad`, `Istanbul`, `Europe/Istanbul`, `Kuwait`, `Asia/Kuwait`, `Minsk`, `Europe/Minsk`, `Moscow`, `Europe/Moscow`, `Nairobi`, `Africa/Nairobi`, `Riyadh`, `Asia/Riyadh`, `St. Petersburg`, `Europe/Moscow`, `Volgograd`, `Europe/Volgograd`, `Tehran`, `Asia/Tehran`, `Abu Dhabi`, `Asia/Muscat`, `Baku`, `Asia/Baku`, `Muscat`, `Asia/Muscat`, `Samara`, `Europe/Samara`, `Tbilisi`, `Asia/Tbilisi`, `Yerevan`, `Asia/Yerevan`, `Kabul`, `Asia/Kabul`, `Almaty`, `Asia/Almaty`, `Astana`, `Asia/Almaty`, `Ekaterinburg`, `Asia/Yekaterinburg`, `Islamabad`, `Asia/Karachi`, `Karachi`, `Asia/Karachi`, `Tashkent`, `Asia/Tashkent`, `Chennai`, `Asia/Kolkata`, `Kolkata`, `Asia/Kolkata`, `Mumbai`, `Asia/Kolkata`, `New Delhi`, `Asia/Kolkata`, `Sri Jayawardenepura`, `Asia/Colombo`, `Kathmandu`, `Asia/Kathmandu`, `Dhaka`, `Asia/Dhaka`, `Urumqi`, `Asia/Urumqi`, `Rangoon`, `Asia/Rangoon`, `Bangkok`, `Asia/Bangkok`, `Hanoi`, `Asia/Bangkok`, `Jakarta`, `Asia/Jakarta`, `Krasnoyarsk`, `Asia/Krasnoyarsk`, `Novosibirsk`, `Asia/Novosibirsk`, `Beijing`, `Asia/Shanghai`, `Chongqing`, `Asia/Chongqing`, `Hong Kong`, `Asia/Hong_Kong`, `Irkutsk`, `Asia/Irkutsk`, `Kuala Lumpur`, `Asia/Kuala_Lumpur`, `Perth`, `Australia/Perth`, `Singapore`, `Asia/Singapore`, `Taipei`, `Asia/Taipei`, `Ulaanbaatar`, `Asia/Ulaanbaatar`, `Osaka`, `Asia/Tokyo`, `Sapporo`, `Asia/Tokyo`, `Seoul`, `Asia/Seoul`, `Tokyo`, `Asia/Tokyo`, `Yakutsk`, `Asia/Yakutsk`, `Adelaide`, `Australia/Adelaide`, `Darwin`, `Australia/Darwin`, `Brisbane`, `Australia/Brisbane`, `Canberra`, `Australia/Canberra`, `Guam`, `Pacific/Guam`, `Hobart`, `Australia/Hobart`, `Melbourne`, `Australia/Melbourne`, `Port Moresby`, `Pacific/Port_Moresby`, `Sydney`, `Australia/Sydney`, `Vladivostok`, `Asia/Vladivostok`, `Magadan`, `Asia/Magadan`, `New Caledonia`, `Pacific/Noumea`, `Solomon Is.`, `Pacific/Guadalcanal`, `Srednekolymsk`, `Asia/Srednekolymsk`, `Auckland`, `Pacific/Auckland`, `Fiji`, `Pacific/Fiji`, `Kamchatka`, `Asia/Kamchatka`, `Marshall Is.`, `Pacific/Majuro`, `Wellington`, `Pacific/Auckland`, `Chatham Is.`, `Pacific/Chatham`, `Nuku'alofa`, `Pacific/Tongatapu`, `Samoa`, `Pacific/Apia`, `Tokelau Is.`, `Pacific/Fakaofo`.",
						Optional:            true,
						Computed:            true,
						CustomType:          supertypes.StringType{},
						Validators: []validator.String{
							stringvalidator.OneOf("International Date Line West", "Etc/GMT+12", "American Samoa", "Pacific/Pago_Pago", "Midway Island", "Pacific/Midway", "Hawaii", "Pacific/Honolulu", "Alaska", "America/Juneau", "Pacific Time (US & Canada)", "America/Los_Angeles", "Tijuana", "America/Tijuana", "Arizona", "America/Phoenix", "Mazatlan", "America/Mazatlan", "Mountain Time (US & Canada)", "America/Denver", "Central America", "America/Guatemala", "Central Time (US & Canada)", "America/Chicago", "Chihuahua", "America/Chihuahua", "Guadalajara", "America/Mexico_City", "Mexico City", "America/Mexico_City", "Monterrey", "America/Monterrey", "Saskatchewan", "America/Regina", "Bogota", "America/Bogota", "Eastern Time (US & Canada)", "America/New_York", "Indiana (East)", "America/Indiana/Indianapolis", "Lima", "America/Lima", "Quito", "America/Lima", "Atlantic Time (Canada)", "America/Halifax", "Caracas", "America/Caracas", "Georgetown", "America/Guyana", "La Paz", "America/La_Paz", "Puerto Rico", "America/Puerto_Rico", "Santiago", "America/Santiago", "Newfoundland", "America/St_Johns", "Asuncion", "America/Asuncion", "Brasilia", "America/Sao_Paulo", "Buenos Aires", "America/Argentina/Buenos_Aires", "Montevideo", "America/Montevideo", "Greenland", "America/Nuuk", "Mid-Atlantic", "Atlantic/South_Georgia", "Azores", "Atlantic/Azores", "Cape Verde Is.", "Atlantic/Cape_Verde", "Casablanca", "Africa/Casablanca", "Dublin", "Europe/Dublin", "Edinburgh", "Europe/London", "Lisbon", "Europe/Lisbon", "London", "Europe/London", "Monrovia", "Africa/Monrovia", "UTC", "Etc/UTC", "Amsterdam", "Europe/Amsterdam", "Belgrade", "Europe/Belgrade", "Berlin", "Europe/Berlin", "Bern", "Europe/Zurich", "Bratislava", "Europe/Bratislava", "Brussels", "Europe/Brussels", "Budapest", "Europe/Budapest", "Copenhagen", "Europe/Copenhagen", "Ljubljana", "Europe/Ljubljana", "Madrid", "Europe/Madrid", "Paris", "Europe/Paris", "Prague", "Europe/Prague", "Rome", "Europe/Rome", "Sarajevo", "Europe/Sarajevo", "Skopje", "Europe/Skopje", "Stockholm", "Europe/Stockholm", "Vienna", "Europe/Vienna", "Warsaw", "Europe/Warsaw", "West Central Africa", "Africa/Algiers", "Zagreb", "Europe/Zagreb", "Zurich", "Europe/Zurich", "Athens", "Europe/Athens", "Bucharest", "Europe/Bucharest", "Cairo", "Africa/Cairo", "Harare", "Africa/Harare", "Helsinki", "Europe/Helsinki", "Jerusalem", "Asia/Jerusalem", "Kaliningrad", "Europe/Kaliningrad", "Kyiv", "Europe/Kiev", "Pretoria", "Africa/Johannesburg", "Riga", "Europe/Riga", "Sofia", "Europe/Sofia", "Tallinn", "Europe/Tallinn", "Vilnius", "Europe/Vilnius", "Baghdad", "Asia/Baghdad", "Istanbul", "Europe/Istanbul", "Kuwait", "Asia/Kuwait", "Minsk", "Europe/Minsk", "Moscow", "Europe/Moscow", "Nairobi", "Africa/Nairobi", "Riyadh", "Asia/Riyadh", "St. Petersburg", "Europe/Moscow", "Volgograd", "Europe/Volgograd", "Tehran", "Asia/Tehran", "Abu Dhabi", "Asia/Muscat", "Baku", "Asia/Baku", "Muscat", "Asia/Muscat", "Samara", "Europe/Samara", "Tbilisi", "Asia/Tbilisi", "Yerevan", "Asia/Yerevan", "Kabul", "Asia/Kabul", "Almaty", "Asia/Almaty", "Astana", "Asia/Almaty", "Ekaterinburg", "Asia/Yekaterinburg", "Islamabad", "Asia/Karachi", "Karachi", "Asia/Karachi", "Tashkent", "Asia/Tashkent", "Chennai", "Asia/Kolkata", "Kolkata", "Asia/Kolkata", "Mumbai", "Asia/Kolkata", "New Delhi", "Asia/Kolkata", "Sri Jayawardenepura", "Asia/Colombo", "Kathmandu", "Asia/Kathmandu", "Dhaka", "Asia/Dhaka", "Urumqi", "Asia/Urumqi", "Rangoon", "Asia/Rangoon", "Bangkok", "Asia/Bangkok", "Hanoi", "Asia/Bangkok", "Jakarta", "Asia/Jakarta", "Krasnoyarsk", "Asia/Krasnoyarsk", "Novosibirsk", "Asia/Novosibirsk", "Beijing", "Asia/Shanghai", "Chongqing", "Asia/Chongqing", "Hong Kong", "Asia/Hong_Kong", "Irkutsk", "Asia/Irkutsk", "Kuala Lumpur", "Asia/Kuala_Lumpur", "Perth", "Australia/Perth", "Singapore", "Asia/Singapore", "Taipei", "Asia/Taipei", "Ulaanbaatar", "Asia/Ulaanbaatar", "Osaka", "Asia/Tokyo", "Sapporo", "Asia/Tokyo", "Seoul", "Asia/Seoul", "Tokyo", "Asia/Tokyo", "Yakutsk", "Asia/Yakutsk", "Adelaide", "Australia/Adelaide", "Darwin", "Australia/Darwin", "Brisbane", "Australia/Brisbane", "Canberra", "Australia/Canberra", "Guam", "Pacific/Guam", "Hobart", "Australia/Hobart", "Melbourne", "Australia/Melbourne", "Port Moresby", "Pacific/Port_Moresby", "Sydney", "Australia/Sydney", "Vladivostok", "Asia/Vladivostok", "Magadan", "Asia/Magadan", "New Caledonia", "Pacific/Noumea", "Solomon Is.", "Pacific/Guadalcanal", "Srednekolymsk", "Asia/Srednekolymsk", "Auckland", "Pacific/Auckland", "Fiji", "Pacific/Fiji", "Kamchatka", "Asia/Kamchatka", "Marshall Is.", "Pacific/Majuro", "Wellington", "Pacific/Auckland", "Chatham Is.", "Pacific/Chatham", "Nuku'alofa", "Pacific/Tongatapu", "Samoa", "Pacific/Apia", "Tokelau Is.", "Pacific/Fakaofo"),
						},
					},
					"days": schema.SetAttribute{
						MarkdownDescription: "Business days",
						Optional:            true,
						Computed:            true,
						CustomType:          supertypes.NewSetTypeOf[string](ctx),
					},
					"start_time": schema.StringAttribute{
						MarkdownDescription: "Start time for business hours (HH:MM)",
						Optional:            true,
						Computed:            true,
						CustomType:          supertypes.StringType{},
					},
					"end_time": schema.StringAttribute{
						MarkdownDescription: "End time for business hours (HH:MM)",
						Optional:            true,
						Computed:            true,
						CustomType:          supertypes.StringType{},
					},
				},
			},
		},
	}

	if ext, ok := any(r).(modifySchemaResponseExtension); ok {
		ext.modifySchemaResponse(ctx, resp)
	}
}

func (r *EscalationPolicyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data EscalationPolicyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Create API call logic
	modelIn := tfutils.MergeDiagnostics(data.ToApi(ctx))(&resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	b, err := jsonapi.Marshal(&modelIn, jsonapi.MarshalClientMode())
	if err != nil {
		resp.Diagnostics.AddError("Provider Error", fmt.Sprintf("Unable to marshal model to JSON: %v", err))
		return
	}

	httpResp, err := r.client.CreateEscalationPolicyWithBodyWithResponse(
		ctx,
		"application/vnd.api+json",
		bytes.NewReader(b),
	)
	if err != nil {
		resp.Diagnostics.AddError("API Error", err.Error())
		return
	} else if httpResp.StatusCode() < 200 || httpResp.StatusCode() >= 300 {
		resp.Diagnostics.AddError("API Error", fmt.Sprintf("Unable to create, got status code: %d", httpResp.StatusCode()))
		return
	} else if httpResp.Body == nil {
		resp.Diagnostics.AddError("API Error", "Unable to create, got empty response")
		return
	}

	var modelOut apiclient.EscalationPolicyResourceModel
	if err := jsonapi.Unmarshal(httpResp.Body, &modelOut); err != nil {
		resp.Diagnostics.AddError("Provider Error", fmt.Sprintf("Unable to unmarshal response: %v", err))
		return
	}

	resp.Diagnostics.Append(data.FromApi(ctx, modelOut)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *EscalationPolicyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data EscalationPolicyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	httpResp, err := r.client.GetEscalationPolicyWithResponse(
		ctx,
		data.Id.ValueString(),
		nil,
	)
	if err != nil {
		resp.Diagnostics.AddError("API Error", err.Error())
		return
	} else if httpResp.StatusCode() < 200 || httpResp.StatusCode() >= 300 {
		resp.Diagnostics.AddError("API Error", fmt.Sprintf("Unable to read, got status code: %d", httpResp.StatusCode()))
		return
	} else if httpResp.Body == nil {
		resp.Diagnostics.AddError("API Error", "Unable to read, got empty response")
		return
	}

	var modelOut apiclient.EscalationPolicyResourceModel
	if err := jsonapi.Unmarshal(httpResp.Body, &modelOut); err != nil {
		resp.Diagnostics.AddError("Provider Error", fmt.Sprintf("Unable to unmarshal response: %v", err))
		return
	}

	resp.Diagnostics.Append(data.FromApi(ctx, modelOut)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *EscalationPolicyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, data EscalationPolicyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read Terraform state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Update API call logic
	var modelIn apiclient.EscalationPolicyResourceModel

	if !data.Name.Equal(plan.Name) {
		modelIn.Name = plan.Name.ValueString()
	}
	if !data.Description.Equal(plan.Description) {
		modelIn.Description = plan.Description.ValueStringPointer()
	}
	if !data.RepeatCount.Equal(plan.RepeatCount) {
		modelIn.RepeatCount = plan.RepeatCount.ValueInt64()
	}
	if !data.CreatedByUserId.Equal(plan.CreatedByUserId) {
		modelIn.CreatedByUserId = plan.CreatedByUserId.ValueInt64()
	}
	if !data.LastUpdatedByUserId.Equal(plan.LastUpdatedByUserId) {
		modelIn.LastUpdatedByUserId = plan.LastUpdatedByUserId.ValueInt64()
	}
	if !data.GroupIds.Equal(plan.GroupIds) {
		if plan.GroupIds.IsKnown() {
			modelIn.GroupIds = tfutils.MergeDiagnostics(plan.GroupIds.Get(ctx))(&resp.Diagnostics)
		} else {
			modelIn.GroupIds = nil
		}
	}
	if !data.ServiceIds.Equal(plan.ServiceIds) {
		if plan.ServiceIds.IsKnown() {
			modelIn.ServiceIds = tfutils.MergeDiagnostics(plan.ServiceIds.Get(ctx))(&resp.Diagnostics)
		} else {
			modelIn.ServiceIds = nil
		}
	}
	if !data.BusinessHours.Equal(plan.BusinessHours) {
		if plan.BusinessHours.IsKnown() {
			model := tfutils.MergeDiagnostics(plan.BusinessHours.Get(ctx))(&resp.Diagnostics)
			if resp.Diagnostics.HasError() {
				return
			}
			modelIn.BusinessHours = ptr.Ptr(tfutils.MergeDiagnostics(model.ToApi(ctx))(&resp.Diagnostics))
		} else {
			modelIn.BusinessHours = nil
		}
	}

	if resp.Diagnostics.HasError() {
		return
	}

	b, err := jsonapi.Marshal(&modelIn, jsonapi.MarshalClientMode())
	if err != nil {
		resp.Diagnostics.AddError("Provider Error", fmt.Sprintf("Unable to marshal model to JSON: %v", err))
		return
	}

	httpResp, err := r.client.UpdateEscalationPolicyWithBodyWithResponse(
		ctx,
		data.Id.ValueString(),
		"application/vnd.api+json",
		bytes.NewReader(b),
	)
	if err != nil {
		resp.Diagnostics.AddError("API Error", err.Error())
		return
	} else if httpResp.StatusCode() < 200 || httpResp.StatusCode() >= 300 {
		resp.Diagnostics.AddError("API Error", fmt.Sprintf("Unable to update, got status code: %d", httpResp.StatusCode()))
		return
	} else if httpResp.Body == nil {
		resp.Diagnostics.AddError("API Error", "Unable to read, got empty response")
		return
	}

	var modelOut apiclient.EscalationPolicyResourceModel
	if err := jsonapi.Unmarshal(httpResp.Body, &modelOut); err != nil {
		resp.Diagnostics.AddError("Provider Error", fmt.Sprintf("Unable to unmarshal response: %v", err))
		return
	}

	resp.Diagnostics.Append(data.FromApi(ctx, modelOut)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *EscalationPolicyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data EscalationPolicyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Delete API call logic
	httpResp, err := r.client.DeleteEscalationPolicyWithResponse(
		ctx,
		data.Id.ValueString(),
	)
	if err != nil {
		resp.Diagnostics.AddError("API Error", err.Error())
		return
	} else if httpResp.StatusCode() == http.StatusNotFound {
		return
	} else if httpResp.StatusCode() < 200 || httpResp.StatusCode() >= 300 {
		resp.Diagnostics.AddError("API Error", fmt.Sprintf("Unable to delete, got status code: %d", httpResp.StatusCode()))
		return
	}
}

func (r *EscalationPolicyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

type EscalationPolicyResourceModel struct {
	Id                  supertypes.StringValue                                                           `tfsdk:"id"`
	Name                supertypes.StringValue                                                           `tfsdk:"name"`
	Description         supertypes.StringValue                                                           `tfsdk:"description"`
	RepeatCount         supertypes.Int64Value                                                            `tfsdk:"repeat_count"`
	CreatedByUserId     supertypes.Int64Value                                                            `tfsdk:"created_by_user_id"`
	LastUpdatedByUserId supertypes.Int64Value                                                            `tfsdk:"last_updated_by_user_id"`
	GroupIds            supertypes.SetValueOf[string]                                                    `tfsdk:"group_ids"`
	ServiceIds          supertypes.SetValueOf[string]                                                    `tfsdk:"service_ids"`
	BusinessHours       supertypes.SingleNestedObjectValueOf[EscalationPolicyResourceModelBusinessHours] `tfsdk:"business_hours"`
}

func (m *EscalationPolicyResourceModel) FromApi(ctx context.Context, data apiclient.EscalationPolicyResourceModel) (diags diag.Diagnostics) {
	m.Id = supertypes.NewStringValue(data.Id)
	m.Name = supertypes.NewStringValue(data.Name)
	m.Description = supertypes.NewStringPointerValue(data.Description)
	m.RepeatCount = supertypes.NewInt64Value(data.RepeatCount)
	m.CreatedByUserId = supertypes.NewInt64Value(data.CreatedByUserId)
	m.LastUpdatedByUserId = supertypes.NewInt64Value(data.LastUpdatedByUserId)
	m.GroupIds = supertypes.NewSetValueOfSlice(ctx, data.GroupIds)
	m.ServiceIds = supertypes.NewSetValueOfSlice(ctx, data.ServiceIds)
	if data.BusinessHours == nil {
		m.BusinessHours = supertypes.NewSingleNestedObjectValueOfNull[EscalationPolicyResourceModelBusinessHours](ctx)
	} else {
		var model EscalationPolicyResourceModelBusinessHours
		diags.Append(model.FromApi(ctx, *data.BusinessHours)...)
		m.BusinessHours = supertypes.NewSingleNestedObjectValueOf[EscalationPolicyResourceModelBusinessHours](ctx, &model)
	}
	return
}

func (m *EscalationPolicyResourceModel) ToApi(ctx context.Context) (data apiclient.EscalationPolicyResourceModel, diags diag.Diagnostics) {
	data.Id = m.Id.ValueString()
	data.Name = m.Name.ValueString()
	data.Description = m.Description.ValueStringPointer()
	data.RepeatCount = m.RepeatCount.ValueInt64()
	data.CreatedByUserId = m.CreatedByUserId.ValueInt64()
	data.LastUpdatedByUserId = m.LastUpdatedByUserId.ValueInt64()
	if m.GroupIds.IsKnown() {
		data.GroupIds = tfutils.MergeDiagnostics(m.GroupIds.Get(ctx))(&diags)
	} else {
		data.GroupIds = nil
	}
	if m.ServiceIds.IsKnown() {
		data.ServiceIds = tfutils.MergeDiagnostics(m.ServiceIds.Get(ctx))(&diags)
	} else {
		data.ServiceIds = nil
	}
	if m.BusinessHours.IsKnown() {
		model := tfutils.MergeDiagnostics(m.BusinessHours.Get(ctx))(&diags)
		if diags.HasError() {
			return
		}
		data.BusinessHours = ptr.Ptr(tfutils.MergeDiagnostics(model.ToApi(ctx))(&diags))
	} else {
		data.BusinessHours = nil
	}
	return
}

type EscalationPolicyResourceModelBusinessHours struct {
	TimeZone  supertypes.StringValue        `tfsdk:"time_zone"`
	Days      supertypes.SetValueOf[string] `tfsdk:"days"`
	StartTime supertypes.StringValue        `tfsdk:"start_time"`
	EndTime   supertypes.StringValue        `tfsdk:"end_time"`
}

func (m *EscalationPolicyResourceModelBusinessHours) FromApi(ctx context.Context, data apiclient.EscalationPolicyResourceModelBusinessHours) (diags diag.Diagnostics) {
	m.TimeZone = supertypes.NewStringPointerValue(data.TimeZone)
	if data.Days == nil {
		m.Days = supertypes.NewSetValueOfNull[string](ctx)
	} else {
		m.Days = supertypes.NewSetValueOfSlice(ctx, *data.Days)
	}
	m.StartTime = supertypes.NewStringPointerValue(data.StartTime)
	m.EndTime = supertypes.NewStringPointerValue(data.EndTime)
	return
}

func (m *EscalationPolicyResourceModelBusinessHours) ToApi(ctx context.Context) (data apiclient.EscalationPolicyResourceModelBusinessHours, diags diag.Diagnostics) {
	data.TimeZone = m.TimeZone.ValueStringPointer()
	if m.Days.IsKnown() {
		data.Days = ptr.Ptr(tfutils.MergeDiagnostics(m.Days.Get(ctx))(&diags))
	} else {
		data.Days = nil
	}
	data.StartTime = m.StartTime.ValueStringPointer()
	data.EndTime = m.EndTime.ValueStringPointer()
	return
}

const inflect = require("./inflect");

function forceMapFor(name) {
  return name.match(/_(params|attributes)$/) && !["resolution_rule_attributes", "alert_template_attributes", "sourceable_attributes"].includes(name)
}

module.exports = (name, resourceSchema, requiredFields, pathIdField) => {
  const nameCamel = inflect.camelize(name);

  return `// DO NOT MODIFY: This file is generated by tools/generate.js. Any changes will be overwritten during the next build.

package provider

import (
	"context"
	"errors"
	"fmt"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/rootlyhq/terraform-provider-rootly/v2/client"
	"github.com/rootlyhq/terraform-provider-rootly/v2/tools"
)

func resource${nameCamel}() *schema.Resource {
	return &schema.Resource{
		CreateContext: resource${nameCamel}Create,
		ReadContext: resource${nameCamel}Read,
		UpdateContext: resource${nameCamel}Update,
		DeleteContext: resource${nameCamel}Delete,
		Importer: &schema.ResourceImporter {
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: map[string]*schema.Schema {
			${schemaFields(resourceSchema, requiredFields, pathIdField)}
		},
	}
}

func resource${nameCamel}Create(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)

	tflog.Trace(ctx, fmt.Sprintf("Creating ${nameCamel}"))

	s := &client.${nameCamel}{}

	${createResourceFields(name, resourceSchema)}

	res, err := c.Create${nameCamel}(s)
	if err != nil {
		return diag.Errorf("Error creating ${name}: %s", err.Error())
	}

	d.SetId(res.ID)
	tflog.Trace(ctx, fmt.Sprintf("created a ${name} resource: %s", d.Id()))

	return resource${nameCamel}Read(ctx, d, meta)
}

func resource${nameCamel}Read(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Reading ${nameCamel}: %s", d.Id()))

	item, err := c.Get${nameCamel}(d.Id())
	if err != nil {
		// In the case of a NotFoundError, it means the resource may have been removed upstream
		// We just remove it from the state.
		if errors.Is(err, client.NewNotFoundError("")) && !d.IsNewResource() {
			tflog.Warn(ctx, fmt.Sprintf("${nameCamel} (%s) not found, removing from state", d.Id()))
			d.SetId("")
			return nil
		}

		return diag.Errorf("Error reading ${name}: %s", d.Id())
	}

	${setResourceFields(name, resourceSchema)}

	return nil
}

func resource${nameCamel}Update(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Updating ${nameCamel}: %s", d.Id()))

	s := &client.${nameCamel}{}

	${updateResourceFields(name, resourceSchema)}

	_, err := c.Update${nameCamel}(d.Id(), s)
	if err != nil {
		return diag.Errorf("Error updating ${name}: %s", err.Error())
	}

	return resource${nameCamel}Read(ctx, d, meta)
}

func resource${nameCamel}Delete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)
	tflog.Trace(ctx, fmt.Sprintf("Deleting ${nameCamel}: %s", d.Id()))

	err := c.Delete${nameCamel}(d.Id())
	if err != nil {
		// In the case of a NotFoundError, it means the resource may have been removed upstream.
		// We just remove it from the state.
		if errors.Is(err, client.NewNotFoundError("")) && !d.IsNewResource() {
			tflog.Warn(ctx, fmt.Sprintf("${nameCamel} (%s) not found, removing from state", d.Id()))
			d.SetId("")
			return nil
		}
		return diag.Errorf("Error deleting ${name}: %s", err.Error())
	}

	d.SetId("")

	return nil
}
`;
};

function excludeDateFields(field) {
  return field !== "created_at" && field !== "updated_at";
}

function setResourceFields(name, resourceSchema) {
  return Object.keys(resourceSchema.properties)
    .filter(excludeDateFields)
    .map((field) => {
      const schema = resourceSchema.properties[field];
      if (schema.type == "array" && schema.items && schema.items.type == "object" && schema.items.properties) {
        return `
          if item.${inflect.camelize(field)} != nil {
              processed_items_${field} := make([]map[string]interface{}, 0)

              for _, c := range item.${inflect.camelize(field)} {
                  if rawItem, ok := c.(map[string]interface{}); ok {
                      // Create a new map with only the fields defined in the schema
                      processed_item_${field} := map[string]interface{}{
                          ${Object.keys(schema.items.properties).map((key) => `"${key}": rawItem["${key}"]`).join(",\n")},
                      }
                      processed_items_${field} = append(processed_items_${field}, processed_item_${field})
                  }
              }

              d.Set("${field}", processed_items_${field})
          } else {
              d.Set("${field}", nil)
          }
        `;
      } else if (schema.type == "object" && schema.properties && !forceMapFor(name)) {
        return `singleton_list_${field} := make([]interface{}, 1, 1)
          processed_item_${field} := map[string]interface{}{
            ${Object.keys(schema.properties).map((key) => `"${key}": item.${inflect.camelize(field)}["${key}"]`).join(",\n")},
          }
          singleton_list_${field}[0] = processed_item_${field}
          d.Set("${field}", singleton_list_${field})
        `;
      }
      return `d.Set("${field}", item.${inflect.camelize(field)})`;
    })
    .join("\n  ");
}

function createResourceFields(name, resourceSchema) {
  return Object.keys(resourceSchema.properties)
    .filter(excludeDateFields)
    .map((field) => {
      const schema = resourceSchema.properties[field];
      if (schema.type === "boolean") {
        return `  if value, ok := d.GetOkExists("${field}"); ok {
				s.${inflect.camelize(field)} = tools.Bool(value.(${jsonapiToGoType(
          schema.type
        )}))
			}`;
      } else if (schema.type == "object" && schema.properties && !forceMapFor(name)) {
        return `  if value, ok := d.GetOkExists("${field}"); ok {
				if valueList, ok := value.([]interface{}); ok && len(valueList) > 0 && valueList[0] != nil {
          if mapValue, ok := valueList[0].(map[string]interface{}); ok {
    				s.${inflect.camelize(field)} = mapValue
          }
        }
			}`;
      } else {
        return `  if value, ok := d.GetOkExists("${field}"); ok {
				s.${inflect.camelize(field)} = value.(${jsonapiToGoType(schema.type)})
			}`;
      }
    })
    .join("\n  ");
}

function updateResourceFields(name, resourceSchema) {
  return Object.keys(resourceSchema.properties)
    .filter(excludeDateFields)
    .map((field) => {
      const schema = resourceSchema.properties[field];
      if (schema.type === "boolean") {
        return `  if d.HasChange("${field}") {
				s.${inflect.camelize(field)} = tools.Bool(d.Get("${field}").(${jsonapiToGoType(
          schema.type
        )}))
			}`;
      } else if (schema.type == "array") {
        return `
          if d.HasChange("${field}") {
            if value, ok := d.GetOk("${field}"); value != nil && ok {
              s.${inflect.camelize(field)} = value.([]interface{})
            } else {
              s.${inflect.camelize(field)} = []interface{}{}
            }
          }
			`;
      } else if (schema.type == "object" && schema.properties && !forceMapFor(name)) {
        return `  if d.HasChange("${field}") {
      		tps := d.Get("${field}").([]interface{})
      		for _, tpsi := range tps {
      			s.${inflect.camelize(field)} = tpsi.(map[string]interface{})
      		}
      	}
			`;
      } else if (schema.tf_include_unchanged) {
        return `
				s.${inflect.camelize(field)} = d.Get("${field}").(${jsonapiToGoType(
          schema.type
        )})
			`;
      } else {
        return `  if d.HasChange("${field}") {
				s.${inflect.camelize(field)} = d.Get("${field}").(${jsonapiToGoType(
          schema.type
        )})
			}`;
      }
    })
    .join("\n  ");
}

function jsonapiToGoType(type) {
  switch (type) {
    case "string":
      return "string";
    case "integer":
      return "int";
    case "number":
      return "float32";
    case "boolean":
      return "bool";
    case "array":
      return "[]interface{}";
    case "object":
      return "map[string]interface{}";
    default:
      return "interface{}";
  }
}

function schemaFields(resourceSchema, requiredFields, pathIdField) {
  return Object.keys(resourceSchema.properties)
    .filter(excludeDateFields)
    .map((field) => {
      return schemaField(field, resourceSchema, requiredFields, pathIdField);
    })
    .join("\n");
}

function annotatedDescription(schema) {
  const description = (schema.description || "").replace(/"/g, '\\"');
  if (schema.enum) {
    return `${
      !!description ? `${description}. ` : ""
    }Value must be one of ${schema.enum
      .map((val) => `\`${val}\``)
      .join(", ")}.`;
  }
  if (
    schema.type === "object" &&
    schema.properties &&
    schema.properties.id &&
    schema.properties.name
  ) {
    return `Map must contain two fields, \`id\` and \`name\`. ${description}`;
  }
  if (schema.type === "array" && schema.items && schema.items.enum) {
    return `${
      !!description ? `${description}. ` : ""
    }Value must be one of ${schema.items.enum
      .map((val) => `\`${val}\``)
      .join(", ")}.`;
  }

  if (schema.type === "boolean") {
    return `${
      !!description ? `${description}. ` : ""
    }Value must be one of true or false`;
  }
  return description;
}

function generateValidateFunc(schema) {
  if (schema.enum && schema.enum.length > 0) {
    const enumValues = schema.enum.map(val => `"${val}"`).join(", ");
    return `
		ValidateFunc: validation.StringInSlice([]string{${enumValues}}, false),`;
  }
  if (schema.type === "array" && schema.items && schema.items.enum && schema.items.enum.length > 0) {
    const enumValues = schema.items.enum.map(val => `"${val}"`).join(", ");
    return `
		ValidateFunc: validation.StringInSlice([]string{${enumValues}}, false),`;
  }
  return "";
}

function schemaField(name, resourceSchema, requiredFields, pathIdField) {
  const schema = resourceSchema.properties[name];
  const optional =
    (requiredFields || []).indexOf(name) === -1 || schema.enum
      ? "true"
      : "false";
  const required =
    (requiredFields || []).indexOf(name) === -1 || schema.enum
      ? "false"
      : "true";
  let defaultValue;
  if (schema.default) {
    defaultValue = `Default: "${schema.default}"`;
  } else if (schema.enum && schema.enum.length > 0 && !schema.anyOfChild && name !== "status") {
    defaultValue = `Default: "${schema.enum[0]}"`;
  } else if (schema.tf_computed === false) {
    defaultValue = `Default: nil,\n				Computed: false`
  } else {
    defaultValue = `Computed: ${optional}`;
  }
  const description = annotatedDescription(schema);
  const sensitive = schema.tf_sensitive ? "true" : "false";
  const forceNew =
    name === pathIdField || schema.tf_force_new ? "true" : "false";
  const writeOnly = schema.tf_write_only ? "true" : "false";
  const skipDiff =
    schema.tf_skip_diff
      ? `
		DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
			return len(old) != 0
		},
	`
      : "";
  const stateFunc = schema.accepts_unordered
    ? `
		StateFunc: func(v interface{}) string {
			json, _ := structure.NormalizeJsonString(v)
			return json
		},
	`
    : "";
  const validateFunc = generateValidateFunc(schema);
  switch (schema.type) {
    case "string":
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeString,
				${defaultValue},
				Required: ${required},
				Optional: ${optional},
        Sensitive: ${sensitive},
				ForceNew: ${forceNew},
        WriteOnly: ${writeOnly},
				Description: "${description}",${validateFunc}
				${skipDiff}
			},
			`;
    case "integer":
      return `
      "${name}": &schema.Schema {
        Type: schema.TypeInt,
        Computed: ${optional},
        Required: ${required},
        Optional: ${optional},
        Sensitive: ${sensitive},
        ForceNew: ${forceNew},
        WriteOnly: ${writeOnly},
        Description: "${description}",
        ${skipDiff}
      },
      `;
    case "number":
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeFloat,
				Computed: ${optional},
				Required: ${required},
				Optional: ${optional},
        Sensitive: ${sensitive},
				ForceNew: ${forceNew},
        WriteOnly: ${writeOnly},
				Description: "${description}",
				${skipDiff}
			},
			`;
    case "boolean":
      if (name === "enabled") {
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeBool,
					Default: true,
					Optional: true,
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
					${skipDiff}
				},
				`;
      }
      return `
        "${name}": &schema.Schema {
          Type: schema.TypeBool,
          Computed: ${optional},
          Required: ${required},
          Optional: ${optional},
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
          Description: "${description}",
          ${skipDiff}
        },
        `;
    case "array":
      if (
        schema.items &&
        schema.items.type === "object" &&
        schema.items.properties
      ) {
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeList,
					Computed: ${schema.tf_computed ? "true" : "false"},
					Required: ${required},
					Optional: ${optional},
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
					Description: "${description}",
					DiffSuppressFunc: tools.EqualIgnoringOrder,
					Elem: &schema.Resource {
						Schema: map[string]*schema.Schema {
              ${Object.keys(schema.items.properties)
                .map((key) => {
                  return schemaField(key, schema.items, [], pathIdField)
                })
                .join("\n")}
						},
					},
					${stateFunc}
				},
				`;
      } else if (schema.items && schema.items.type === "string") {
        const elemValidateFunc = schema.items.enum && schema.items.enum.length > 0 
          ? `\n\t\t\t\t\tValidateFunc: validation.StringInSlice([]string{${schema.items.enum.map(val => `"${val}"`).join(", ")}}, false),`
          : "";
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeList,
					Elem: &schema.Schema {
						Type: schema.TypeString,${elemValidateFunc}
					},
					DiffSuppressFunc: tools.EqualIgnoringOrder,
					Computed: ${schema.tf_computed ? "true" : "false"},
					Required: ${required},
					Optional: ${optional},
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
					Description: "${description}",
					${stateFunc}
				},
				`;
      } else if (schema.items && schema.items.type === "number") {
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeList,
					Elem: &schema.Schema {
						Type: schema.TypeInt,
					},
					DiffSuppressFunc: tools.EqualIgnoringOrder,
					Computed: ${schema.tf_computed ? "true" : "false"},
					Required: ${required},
					Optional: ${optional},
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
					Description: "${description}",
					${stateFunc}
				},
				`;
      } else if (schema.items && schema.items.type === "integer") {
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeList,
					Elem: &schema.Schema {
						Type: schema.TypeInt,
					},
					DiffSuppressFunc: tools.EqualIgnoringOrder,
					Computed: ${schema.tf_computed ? "true" : "false"},
					Required: ${required},
					Optional: ${optional},
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
					Description: "${description}",
					${stateFunc}
				},
				`;
      } else {
        console.log(`unsupported array field schema:`, name, schema);
        return "";
      }
    case "object":
    default:
      if (schema.properties && !forceMapFor(name)) {
        return `
   			"${name}": &schema.Schema {
	 				Type: schema.TypeList,
	 				Computed: ${optional},
	 				Required: ${required},
	 				Optional: ${optional},
          Sensitive: ${sensitive},
          ForceNew: ${forceNew},
          WriteOnly: ${writeOnly},
	 				Description: "${description}",
						MinItems: 0,
						MaxItems: 1,
	 					Elem: &schema.Resource {
							Schema: map[string]*schema.Schema {
	 							${Object.keys(schema.properties)
									.map((key) => {
	 									return schemaField(key, schema, [], pathIdField)
									})
									.join("\n")}
							},
	 					},
	 				},
   			`;
      }
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeMap,
				Elem: &schema.Schema {
					Type: schema.TypeString,
				},
				Computed: ${optional},
				Required: ${required},
				Optional: ${optional},
				Description: "${description}",
			},
			`;
  }
}

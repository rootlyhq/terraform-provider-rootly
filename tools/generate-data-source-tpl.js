const inflect = require("./inflect");

function filterCamelize(name) {
  return inflect.camelize(name.replace(/[\[\]]+/g, "_").replace(/_$/, ""));
}

function filterUnderscore(name) {
  return inflect.underscore(filterCamelize(name)).replace("filter_", "");
}

module.exports = (name, resourceSchema, filterParameters, pathIdField) => {
  const namePlural = inflect.pluralize(name);
  const nameCamel = inflect.camelize(name);
  const nameCamelPlural = inflect.camelize(namePlural);

  return `// DO NOT MODIFY: This file is generated by tools/generate.js. Any changes will be overwritten during the next build.

package provider

import (
	"context"
	"strconv"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/rootlyhq/terraform-provider-rootly/v2/client"
	rootlygo "github.com/rootlyhq/terraform-provider-rootly/v2/schema"
)

func dataSource${nameCamel}() *schema.Resource {
	return &schema.Resource {
		ReadContext: dataSource${nameCamel}Read,
		Schema: map[string]*schema.Schema {
			"id": &schema.Schema {
				Type: schema.TypeString,
				Computed: true,
			},
			${schemaFields(resourceSchema, filterParameters)}
		},
	}
}

func dataSource${nameCamel}Read(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	c := meta.(*client.Client)

	params := new(rootlygo.List${nameCamelPlural}Params)
	page_size := 1
	params.PageSize = &page_size

	${setFilterFields(name, resourceSchema, filterParameters)}

	${listFn(nameCamelPlural, resourceSchema, pathIdField)}
	if err != nil {
		return diag.FromErr(err)
	}

	if len(items) == 0 {
		return diag.Errorf("${name} not found")
	}
	item, _ := items[0].(*client.${nameCamel})

	d.SetId(item.ID)
	${setOutputFields(resourceSchema, filterParameters)}
	return nil
}
`;
};

function listFn(nameCamelPlural, resourceSchema, pathIdField) {
  if (pathIdField) {
    if (resourceSchema.properties[pathIdField].type === "number") {
      return `${pathIdField} := strconv.Itoa(d.Get("${pathIdField}").(int))
			items, err := c.List${nameCamelPlural}(${pathIdField}, params)`;
    } else {
      return `${pathIdField} := d.Get("${pathIdField}").(string)
			items, err := c.List${nameCamelPlural}(${pathIdField}, params)`;
    }
  } else {
    return `items, err := c.List${nameCamelPlural}(params)`;
  }
}

function setFilterFields(name, resourceSchema, filterParameters) {
  // Some API boolean filters expect strings instead of booleans
  const booleanAsStringFilters = {
    'communications_group': ['is_private']
  };

  return (filterParameters || [])
    .filter((paramSchema) => {
      return paramSchema.name.match(/^filter/);
    })
    .map((paramSchema) => {
      const filterField = filterUnderscore(paramSchema.name);
      // Try to find the field in the schema, checking both plural and singular forms
      // This handles API plural filter names (filter[source_types]) vs singular schema properties (source_type)
      let fieldSchema = resourceSchema.properties[filterField];
      let schemaFieldName = filterField;
      if (!fieldSchema) {
        const singularField = inflect.singularize(filterField);
        if (singularField !== filterField && resourceSchema.properties[singularField]) {
          fieldSchema = resourceSchema.properties[singularField];
          schemaFieldName = singularField;
        }
      }
      if (fieldSchema) {
        if (fieldSchema.type === 'boolean') {
          // Check if this boolean field should be converted to string for this resource
          const shouldConvertToString = booleanAsStringFilters[name] &&
            booleanAsStringFilters[name].includes(schemaFieldName);

          if (shouldConvertToString) {
            return `
				if value, ok := d.GetOkExists("${schemaFieldName}"); ok {
					${schemaFieldName} := value.(bool)
					${schemaFieldName}_str := "false"
					if ${schemaFieldName} {
						${schemaFieldName}_str = "true"
					}
					params.${filterCamelize(paramSchema.name)} = &${schemaFieldName}_str
				}
			`;
          } else {
            return `
				if value, ok := d.GetOkExists("${schemaFieldName}"); ok {
					${schemaFieldName} := value.(bool)
					params.${filterCamelize(paramSchema.name)} = &${schemaFieldName}
				}
			`;
          }
        } else {
          return `
				if value, ok := d.GetOkExists("${schemaFieldName}"); ok {
					${schemaFieldName} := value.(${jsonapiToGoType(fieldSchema.type)})
					params.${filterCamelize(paramSchema.name)} = &${schemaFieldName}
				}
			`;
        }
      } else if (paramSchema.name.match(/(lt|gt)\]/)) {
        const rangeKey = filterField.split("_").pop();
        return `
				${filterField} := d.Get("${filterField.replace(
          /_(lt|gt)$/,
          ""
        )}").(map[string]interface{})
				if value, exists := ${filterField}["${rangeKey}"]; exists {
					v := value.(string)
					params.${filterCamelize(paramSchema.name)} = &v
				}
			`;
      }
    })
    .filter((x) => x)
    .join("\n");
}

function setOutputFields(resourceSchema, filterParameters) {
  // Generate d.Set() calls for filter fields so they're available in Terraform state
  return (filterParameters || [])
    .filter((paramSchema) => {
      return paramSchema.name.match(/^filter/) && !paramSchema.name.match(/(lt|gt)\]/);
    })
    .map((paramSchema) => {
      const filterField = filterUnderscore(paramSchema.name);
      // Try to find the field in the schema, checking both plural and singular forms
      let fieldSchema = resourceSchema.properties[filterField];
      let schemaFieldName = filterField;
      if (!fieldSchema) {
        const singularField = inflect.singularize(filterField);
        if (singularField !== filterField && resourceSchema.properties[singularField]) {
          fieldSchema = resourceSchema.properties[singularField];
          schemaFieldName = singularField;
        }
      }
      if (fieldSchema) {
        // Convert Go field name (e.g., SourceType) from schema field name (e.g., source_type)
        const goFieldName = inflect.camelize(schemaFieldName);
        return `d.Set("${schemaFieldName}", item.${goFieldName})`;
      }
    })
    .filter((x) => x)
    .join("\n\t");
}

function jsonapiToGoType(type) {
  switch (type) {
    case "string":
      return "string";
    case "integer":
      return "int";
    case "number":
      return "float32";
    case "boolean":
      return "bool";
    default:
      return "string";
  }
}

function schemaFields(resourceSchema, filterParameters) {
  return Object.keys(resourceSchema.properties)
    .filter((name) => {
      if (name === "id") return false;
      // Check if any filter parameter matches this schema field (handling plural/singular variants)
      return filterParameters.some((param) => {
        const filterField = filterUnderscore(param.name);
        const singularField = inflect.singularize(filterField);
        // Match if filter field name matches, or if singular form matches
        return filterField === name || singularField === name || param.name.match(name);
      });
    })
    .map((name) => {
      return schemaField(name, resourceSchema);
    })
    .join("\n");
}

function generateValidateFunc(schema) {
  if (schema.enum && schema.enum.length > 0) {
    const enumValues = schema.enum.map(val => `"${val}"`).join(", ");
    return `
		ValidateFunc: validation.StringInSlice([]string{${enumValues}}, false),`;
  }
  if (schema.type === "array" && schema.items && schema.items.enum && schema.items.enum.length > 0) {
    const enumValues = schema.items.enum.map(val => `"${val}"`).join(", ");
    return `
		ValidateFunc: validation.StringInSlice([]string{${enumValues}}, false),`;
  }
  return "";
}

function schemaField(name, resourceSchema, filterParameters) {
  const schema = resourceSchema.properties[name];
  const validateFunc = generateValidateFunc(schema);
  
  switch (schema.type) {
    case "integer":
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeInt,
				Computed: true,
				Optional: true,
			},
			`;
    case "number":
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeFloat,
				Computed: true,
				Optional: true,
			},
			`;
    case "boolean":
      if (name === "enabled") {
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeBool,
					Default: true,
					Optional: true,
				},
				`;
      }
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeBool,
				Computed: true,
				Optional: true,
			},
			`;
    case "string":
    default:
      if (name.match(/_at$/)) {
        return `
				"${name}": &schema.Schema {
					Type: schema.TypeMap,
					Description: "Filter by date range using 'lt' and 'gt'.",
					Optional: true,
				},
				`;
      }
      return `
			"${name}": &schema.Schema {
				Type: schema.TypeString,
				Computed: true,
				Optional: true,${validateFunc}
			},
			`;
  }
}

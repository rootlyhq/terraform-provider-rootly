const inflect = require("./inflect");

module.exports = (name, resourceSchema, pathIdField, hasIncludeParam) => {
  const namePlural = inflect.pluralize(name);
  const nameCamel = inflect.camelize(name);
  const nameCamelPlural = inflect.camelize(namePlural);
  const needsStrconv = pathIdField && resourceSchema.properties[pathIdField] && resourceSchema.properties[pathIdField].type === "number";

  return `// DO NOT MODIFY: This file is generated by tools/generate.js. Any changes will be overwritten during the next build.

package client

import (
	"reflect"
	${needsStrconv ? '"strconv"' : ''}
	"fmt"
	"github.com/google/jsonapi"
	rootlygo "github.com/rootlyhq/terraform-provider-rootly/v2/schema"
)

type ${nameCamel} struct {
	ID string \`jsonapi:"primary,${clientJsonApiResourceType(name)}"\`
	${structAttrs(resourceSchema, name)}
}

func (c *Client) List${nameCamelPlural}(${listFnParams(
    nameCamelPlural,
    pathIdField
  )}) ([]interface{}, error) {
	${name === 'override_shift' ? `var allItems []interface{}
	page := 1
	
	// If params is nil, initialize it
	if params == nil {
		params = &rootlygo.List${nameCamelPlural}Params{}
	}

	for {
		// Set the current page number
		params.PageNumber = &page

		req, err := rootlygo.NewList${nameCamelPlural}Request(${listClientParams(pathIdField)})
		if err != nil {
			return nil, fmt.Errorf("Error building request: %w", err)
		}

		resp, err := c.Do(req)
		if err != nil {
			return nil, fmt.Errorf("Failed to make request: %w", err)
		}

		${namePlural}, err := jsonapi.UnmarshalManyPayload(resp.Body, reflect.TypeOf(new(${nameCamel})))
		resp.Body.Close()
		if err != nil {
			return nil, fmt.Errorf("Error unmarshaling: %w", err)
		}

		// Add the items from this page to our collection
		allItems = append(allItems, ${namePlural}...)

		// If we got fewer items than a full page, we're done
		// (assuming default page size is around 25-100)
		if len(${namePlural}) == 0 || len(${namePlural}) < 25 {
			break
		}

		page++
	}

	return allItems, nil` : `req, err := rootlygo.NewList${nameCamelPlural}Request(${listClientParams(pathIdField)})
	if err != nil {
		return nil, fmt.Errorf("Error building request: %w", err)
	}

	resp, err := c.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Failed to make request: %w", err)
	}

	${namePlural}, err := jsonapi.UnmarshalManyPayload(resp.Body, reflect.TypeOf(new(${nameCamel})))
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("Error unmarshaling: %w", err)
	}

	return ${namePlural}, nil`}
}

func (c *Client) Create${nameCamel}(d *${nameCamel}) (*${nameCamel}, error) {
	buffer, err := MarshalData(d)
	if err != nil {
		return nil, fmt.Errorf("Error marshaling ${name}: %w", err)
	}

	req, err := rootlygo.NewCreate${nameCamel}RequestWithBody(${createParams(
    pathIdField,
    resourceSchema
  )})
	if err != nil {
		return nil, fmt.Errorf("Error building request: %w", err)
	}
	resp, err := c.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Failed to perform request to create ${name}: %s", err)
	}

	data, err := UnmarshalData(resp.Body, new(${nameCamel}))
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("Error unmarshaling ${name}: %w", err)
	}

	return data.(*${nameCamel}), nil
}

func (c *Client) Get${nameCamel}(id string) (*${nameCamel}, error) {
	${name === 'override_shift' ? '// NOTE: This GET endpoint is broken in the Rootly API and returns 404 for valid shifts\n\t// The provider uses List' + nameCamel + 's instead. This function is kept for backwards compatibility.\n\t' : ''}req, err := rootlygo.NewGet${nameCamel}Request(c.Rootly.Server, id${hasIncludeParam ? ', nil' : ''})
	if err != nil {
		return nil, fmt.Errorf("Error building request: %w", err)
	}

	resp, err := c.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Failed to make request to get ${name}: %w", err)
	}

	data, err := UnmarshalData(resp.Body, new(${nameCamel}))
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("Error unmarshaling ${name}: %w", err)
	}

	return data.(*${nameCamel}), nil
}

func (c *Client) Update${nameCamel}(id string, ${name} *${nameCamel}) (*${nameCamel}, error) {
	buffer, err := MarshalData(${name})
	if err != nil {
		return nil, fmt.Errorf("Error marshaling ${name}: %w", err)
	}

	req, err := rootlygo.NewUpdate${nameCamel}RequestWithBody(c.Rootly.Server, id, c.ContentType, buffer)
	if err != nil {
		return nil, fmt.Errorf("Error building request: %w", err)
	}
	resp, err := c.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Failed to make request to update ${name}: %w", err)
	}

	data, err := UnmarshalData(resp.Body, new(${nameCamel}))
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("Error unmarshaling ${name}: %w", err)
	}

	return data.(*${nameCamel}), nil
}

func (c *Client) Delete${nameCamel}(id string) error {
	req, err := rootlygo.NewDelete${nameCamel}Request(c.Rootly.Server, id)
	if err != nil {
		return fmt.Errorf("Error building request: %w", err)
	}

	_, err = c.Do(req)
	if err != nil {
		return fmt.Errorf("Failed to make request to delete ${name}: %w", err)
	}

	return nil
}
`;
};

function clientJsonApiResourceType(name) {
  if (name === "team") return "groups";
  if (name === "alerts_source") return "alert_sources";
  if (name === "override_shift") return "shifts";
  return inflect.pluralize(name);
}

function listFnParams(nameCamelPlural, nested) {
  if (nested) {
    return `id string, params *rootlygo.List${nameCamelPlural}Params`;
  } else {
    return `params *rootlygo.List${nameCamelPlural}Params`;
  }
}

function listClientParams(nested) {
  if (nested) {
    return `c.Rootly.Server, id, params`;
  } else {
    return `c.Rootly.Server, params`;
  }
}

function createParams(pathIdField, resourceSchema) {
  if (pathIdField) {
    const schema = resourceSchema.properties[pathIdField];
    if (schema.type === "number") {
      return `c.Rootly.Server, strconv.Itoa(d.${inflect.camelize(
        pathIdField
      )}), c.ContentType, buffer`;
    } else {
      return `c.Rootly.Server, d.${inflect.camelize(
        pathIdField
      )}, c.ContentType, buffer`;
    }
  } else {
    return `c.Rootly.Server, c.ContentType, buffer`;
  }
}

function structAttr(name, resourceSchema) {
  const schema = resourceSchema.properties[name];
  switch (schema.type) {
    case "string":
      return `${inflect.camelize(
        name
      )} string \`jsonapi:"attr,${name}${schema.tf_computed === false ? "" : ",omitempty"}"\``;
    case "integer":
      return `${inflect.camelize(
        name
      )} int \`jsonapi:"attr,${name},omitempty"\``;
    case "number":
      return `${inflect.camelize(
        name
      )} float32 \`jsonapi:"attr,${name},omitempty"\``;
    case "boolean":
      return `${inflect.camelize(
        name
      )} *bool \`jsonapi:"attr,${name},omitempty"\``;
    case "array":
      return `${inflect.camelize(
        name
      )} []interface{} \`jsonapi:"attr,${name},omitempty"\``;
    case "object":
    default:
      return `${inflect.camelize(
        name
      )} map[string]interface{} \`jsonapi:"attr,${name},omitempty"\``;
  }
}

function structAttrs(resourceSchema, resourceName) {
  return Object.keys(resourceSchema.properties)
    .filter((name) => {
      return name !== "created_at" && name !== "updated_at";
    })
    .map((name) => {
      // Special case: override_shift uses user_id for create/update, and user as a relation for read
      if (resourceName === "override_shift" && name === "user") {
        return `UserId        int    \`jsonapi:"attr,user_id,omitempty"\`\n\tUser          *User  \`jsonapi:"relation,user,omitempty"\``;
      }
      return structAttr(name, resourceSchema);
    })
    .join("\n  ");
}
